name: CI/CD UAT Promote

on:
  workflow_run:
    workflows: ["Auto Tag from Merge"]
    types: [completed]

permissions:
  contents: write          # push branches/tags
  pull-requests: read      # read PRs/labels via gh api

concurrency:
  group: uat
  cancel-in-progress: true

jobs:
  build-candidate-and-image:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'develop' }}
    runs-on: ubuntu-latest
    outputs:
      prs_included: ${{ steps.filter.outputs.prs_included }}
      docker_tag:   ${{ steps.tag.outputs.docker_tag }}
    steps:
      - name: Checkout repo at current default
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure tooling
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq
          echo "${{ github.token }}" | gh auth login --with-token

      - name: Discover last UAT tag and time
        id: last
        run: |
          set -euo pipefail
          git fetch --tags --force
          # Prefer tags reachable from uat to avoid stale tags
          git fetch origin uat --prune
          LAST="$(git tag --merged origin/uat | grep -E '^uat-v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1 || true)"
          if [ -n "$LAST" ]; then
            TS="$(git log -1 --format=%ct "$LAST")"
            ISO="$(date -u -d "@$TS" +%Y-%m-%dT%H:%M:%SZ)"
          else
            ISO=""
          fi
          echo "last_tag=$LAST" >> "$GITHUB_OUTPUT"
          echo "last_iso=$ISO"  >> "$GITHUB_OUTPUT"

      - name: Collect PRs merged into develop since last UAT tag
        id: collect
        env:
          REPO: ${{ github.repository }}
          LAST: ${{ steps.last.outputs.last_iso }}
        run: |
          set -euo pipefail
          # Pull merged PRs to develop with details we need
          gh pr list --repo "$REPO" --state merged --search 'base:develop' --limit 1000 \
            --json number,mergedAt,labels,mergeCommit \
          | jq -c --arg last "${LAST:-}" '
              map(select(.mergedAt != null))
              | (if $last == "" then . else map(select(.mergedAt > $last)) end)
            ' > /tmp/merged.json

          # For each PR, also fetch commit SHAs (handles squash/rebase merges)
          jq -r '.[].number' /tmp/merged.json | while read -r n; do
            gh pr view "$n" --repo "$REPO" --json commits \
            | jq -c --arg n "$n" '{number:$n|tonumber, commits:[.commits[].oid]}' \
            >> /tmp/commitlists.json
          done

      - name: Split to included (label promote:uat)
        id: filter
        run: |
          set -euo pipefail
          # Build a map pr -> commits
          jq -s 'map({(.number|tostring): .commits}) | add' /tmp/commitlists.json > /tmp/pr2commits.json

          # Included = has label "promote:uat"
          jq -c '
            [ .[] | select([.labels[].name] // [] | index("promote:uat")) ] as $inc
            | { included: $inc }
          ' /tmp/merged.json > /tmp/included.json

          PRS="$(jq -r '[.included[].number] | join(",")' /tmp/included.json)"
          echo "prs_included=$PRS" >> "$GITHUB_OUTPUT"

      - name: Create uat-candidate from current UAT and cherry-pick included PRs
        if: ${{ steps.filter.outputs.prs_included != '' }}
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          git fetch origin uat develop --prune
          git checkout -B uat-candidate origin/uat

          # Order PRs by mergedAt ascending to preserve chronology
          jq -r '
            .included
            | sort_by(.mergedAt)
            | .[].number
          ' /tmp/included.json > /tmp/pr_order.txt

          while read -r PR; do
            [ -z "$PR" ] && continue
            echo "::group::Cherry-picking PR #$PR"
            # Get the commit list for this PR (already fetched)
            COMMITS=$(jq -r --arg pr "$PR" '.[$pr] // [] | .[]' /tmp/pr2commits.json)
            if [ -z "$COMMITS" ]; then
              echo "No commits found for PR #$PR, skipping."
              echo "::endgroup::"
              continue
            fi
            # Cherry-pick each commit in order; resolve trivial conflicts favoring current (uat) when needed
            ok=true
            for c in $COMMITS; do
              if git cherry-pick -X theirs --keep-redundant-commits "$c"; then
                echo "Picked $c"
              else
                echo "Conflict on $c; aborting this PR."
                ok=false
                git cherry-pick --abort || true
                break
              fi
            done
            if $ok; then
              echo "PR #$PR applied."
            fi
            echo "::endgroup::"
          done < /tmp/pr_order.txt

          git push -f origin uat-candidate

      - name: Determine UAT docker tag (uat-vX.Y.Z)
        id: tag
        run: |
          set -euo pipefail
          git fetch --tags --force
          LAST="$(git tag --list 'uat-v*' | sort -V | tail -n1 || true)"
          if [ -z "$LAST" ]; then
            NEXT="uat-v0.1.0"
          else
            # bump patch: uat-vX.Y.(Z+1)
            base="${LAST#uat-v}"
            IFS='.' read -r X Y Z <<< "$base"
            Z=$((Z+1))
            NEXT="uat-v${X}.${Y}.${Z}"
          fi
          echo "docker_tag=$NEXT" >> "$GITHUB_OUTPUT"
          echo "Using UAT tag: $NEXT"

      - name: Docker login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push image from uat-candidate
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            apexdev23/sms-gw:${{ steps.tag.outputs.docker_tag }}
            apexdev23/sms-gw:latest-uat

  merge-and-deploy:
    needs: build-candidate-and-image
    if: ${{ needs.build-candidate-and-image.outputs.prs_included != '' }}
    runs-on: [self-hosted, uat]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Docker login on server
        run: |
          echo ${{ secrets.DOCKERHUB_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

      - name: Merge uat-candidate -> uat
        run: |
          set -euo pipefail
          git fetch origin uat-candidate uat --prune
          git checkout uat
          git reset --hard origin/uat
          if git merge --ff-only origin/uat-candidate; then
            echo "Fast-forwarded uat."
          else
            git merge --no-ff origin/uat-candidate -m "UAT promote: labeled PRs only"
          fi
          git push origin uat

      - name: Deploy App
        run: |
          set -euo pipefail
          cd ~/sms-gw
          ./deploy.sh ${{ needs.build-candidate-and-image.outputs.docker_tag }}

      - name: Move/Create UAT tag to new uat HEAD
        run: |
          set -euo pipefail
          git fetch --tags --force
          git checkout uat
          git pull --ff-only
          TAG="${{ needs.build-candidate-and-image.outputs.docker_tag }}"
          git tag -f "$TAG"
          git push origin "$TAG" --force

      - name: Remove promote:uat label from shipped PRs (optional)
        if: ${{ success() }}
        env:
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "${{ needs.build-candidate-and-image.outputs.prs_included }}" | tr ',' '\n' | while read -r n; do
            [ -z "$n" ] && continue
            gh pr edit "$n" --repo "$REPO" --remove-label "promote:uat" || true
          done

name: CI/CD UAT Deploy

on:
  workflow_dispatch:
  
permissions:
  contents: write
  pull-requests: read

concurrency:
  group: uat
  cancel-in-progress: true

jobs:
  prepare-candidate:
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.collect.outputs.has_prs }}
      prs: ${{ steps.collect.outputs.prs }}
      docker_tag: ${{ steps.version.outputs.docker_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure jq + gh
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      - name: Find PRs marked for UAT
        id: collect
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          git fetch --tags origin
          LAST_TAG=$(git tag --sort=-creatordate | grep '^uat-v' | head -n1 || true)

          if [ -n "$LAST_TAG" ]; then
            DATE=$(git log -1 --format=%ct "$LAST_TAG")
            SINCE=$(date -u -d "@$DATE" +%Y-%m-%d)
            SEARCH="label:\"promote:uat\" base:develop merged:>=$SINCE"
          else
            SEARCH="label:\"promote:uat\" base:develop"
          fi

          echo "Search query: $SEARCH"

          # Collect PR numbers
          gh pr list --repo "$REPO" --state merged --search "$SEARCH" \
            --json number | jq -r '.[].number' > prs.txt

          if [ ! -s prs.txt ]; then
            echo "prs=" >> "$GITHUB_OUTPUT"
            echo "has_prs=false" >> "$GITHUB_OUTPUT"
            echo "No PRs found for UAT promotion."
            exit 0
          fi

          PRS=$(paste -sd, prs.txt)
          echo "prs=$PRS" >> "$GITHUB_OUTPUT"
          echo "has_prs=true" >> "$GITHUB_OUTPUT"
          echo "PRs to promote: $PRS"

          # Improved commit SHA collection
          > commits.txt
          while read pr; do
            [ -z "$pr" ] && continue
            
            echo "Processing PR #$pr"
            
            # Try to get merge commit first
            MERGE_SHA=$(gh pr view "$pr" --repo "$REPO" --json mergeCommit -q '.mergeCommit.oid' 2>/dev/null || true)
            
            if [ -n "$MERGE_SHA" ] && [ "$MERGE_SHA" != "null" ]; then
              echo "Using merge commit: $MERGE_SHA"
              echo "$MERGE_SHA" >> commits.txt
              continue
            fi

            # Fallback to head commit
            HEAD_SHA=$(gh pr view "$pr" --repo "$REPO" --json commits -q '.commits[-1].oid' 2>/dev/null || true)
            
            if [ -n "$HEAD_SHA" ] && [ "$HEAD_SHA" != "null" ]; then
              echo "Using head commit: $HEAD_SHA"
              echo "$HEAD_SHA" >> commits.txt
            else
              echo "Warning: Could not find commit for PR #$pr"
            fi
          done < prs.txt

          echo "Collected commits:"
          cat commits.txt

          # Verify we have valid commit SHAs
          if [ -s commits.txt ]; then
            while read commit; do
              if [ -n "$commit" ] && git rev-parse --verify "$commit" >/dev/null 2>&1; then
                echo "Valid commit: $commit"
              else
                echo "Error: Invalid commit SHA found: '$commit'"
                exit 1
              fi
            done < commits.txt
          else
            echo "Error: No valid commits found for cherry-picking"
            exit 1
          fi

      - name: Build uat-candidate branch
        if: ${{ steps.collect.outputs.has_prs == 'true' }}
        run: |
          set -euo pipefail
          git fetch origin uat
          git checkout -B uat-candidate origin/uat
      
          while read commit; do
            [ -z "$commit" ] && continue
            echo "Cherry-picking $commit"
            
            # Check if this is a merge commit (has two parents)
            if git show --no-patch --format="%P" "$commit" | grep -q " "; then
              echo "This is a merge commit, using mainline parent (-m 1)"
              git cherry-pick -m 1 "$commit" || exit 1
            else
              git cherry-pick "$commit" || exit 1
            fi
          done < commits.txt
      
          git push origin uat-candidate --force

      - name: Set Docker tag
        id: version
        if: ${{ steps.collect.outputs.has_prs == 'true' }}
        run: |
          LATEST=$(git tag --sort=-creatordate | grep '^uat-v' | head -n1 || echo "uat-v0.0.0")
          BASE="${LATEST#uat-v}"
          IFS=. read -r MAJOR MINOR PATCH <<< "$BASE"
          PATCH=$((PATCH+1))
          NEW="uat-v$MAJOR.$MINOR.$PATCH"
          echo "docker_tag=$NEW" >> "$GITHUB_OUTPUT"
          echo "Using Docker tag: $NEW"

  build-and-push:
    needs: prepare-candidate
    if: ${{ needs.prepare-candidate.outputs.should_deploy == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      docker_tag: ${{ needs.prepare-candidate.outputs.docker_tag }}
      prs: ${{ needs.prepare-candidate.outputs.prs }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: uat-candidate
          fetch-depth: 0

      - name: Docker login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            apexdev23/sms-gw:${{ needs.prepare-candidate.outputs.docker_tag }}
            apexdev23/sms-gw:latest-uat

  deploy-uat:
    needs: build-and-push
    runs-on: [self-hosted, uat]
    steps:
      - uses: actions/checkout@v4

      - name: Docker login on server
        run: |
          echo ${{ secrets.DOCKERHUB_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

      - name: Deploy App
        run: |
          cd ~/sms-gw
          ./deploy.sh ${{ needs.build-and-push.outputs.docker_tag }}

      - name: Merge candidate -> uat and tag
        if: ${{ success() }}
        run: |
          git fetch origin
          git checkout uat
          git merge --ff-only origin/uat-candidate
          git push origin uat

          VERSION=${{ needs.build-and-push.outputs.docker_tag }}
          git tag -f "$VERSION"
          git push origin "$VERSION" --force

      - name: Remove promote:uat labels
        if: ${{ success() && needs.build-and-push.outputs.prs != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          IFS=',' read -ra arr <<< "${{ needs.build-and-push.outputs.prs }}"
          for num in "${arr[@]}"; do
            echo "Removing label from PR #$num"
            gh pr edit "$num" --remove-label "promote:uat" --repo "$REPO" || true
          done

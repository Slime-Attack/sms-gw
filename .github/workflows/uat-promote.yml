name: CI/CD UAT Promote (labeled PRs only)

on:
  workflow_run:
    workflows: ["Auto Tag from Merge"]
    types: [completed]

permissions:
  contents: write          # push branches/tags
  pull-requests: write     # create/edit PRs

concurrency:
  group: uat-promote
  cancel-in-progress: true

jobs:
  promote:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'develop' }}
    runs-on: ubuntu-latest
    outputs:
      prs_included: ${{ steps.filter.outputs.prs_included }}
      pr_number: ${{ steps.uat_pr.outputs.pr_number }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq and gh
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq
          echo "${{ github.token }}" | gh auth login --with-token

      - name: Find last UAT tag (reachable from uat) + timestamp
        id: last
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin uat --prune
          git fetch --tags --force
          LAST="$(git tag --merged origin/uat | grep -E '^uat-v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1 || true)"
          if [ -n "$LAST" ]; then
            TS="$(git log -1 --format=%ct "$LAST")"
            ISO="$(date -u -d "@$TS" +%Y-%m-%dT%H:%M:%SZ)"
          else
            ISO=""
          fi
          echo "last_tag=$LAST" >> "$GITHUB_OUTPUT"
          echo "last_iso=$ISO"  >> "$GITHUB_OUTPUT"

      - name: Collect PRs merged into develop since last UAT tag
        id: collect
        env:
          REPO: ${{ github.repository }}
          LAST: ${{ steps.last.outputs.last_iso }}
        shell: bash
        run: |
          set -euo pipefail
          gh pr list --repo "$REPO" --state merged --search 'base:develop' --limit 1000 \
            --json number,mergedAt,labels,mergeCommit \
          | jq -c --arg last "${LAST:-}" '
              map(select(.mergedAt != null))
              | (if $last == "" then . else map(select(.mergedAt > $last)) end)
            ' > /tmp/merged.json

          # For each PR, fetch full commit list (works for merge/squash/rebase)
          : > /tmp/commitlists.json
          jq -r '.[].number' /tmp/merged.json | while read -r n; do
            gh pr view "$n" --repo "$REPO" --json commits \
            | jq -c --arg n "$n" '{number:($n|tonumber), commits:[.commits[].oid]}' \
            >> /tmp/commitlists.json
          done

      - name: Filter to included PRs (label promote:uat) and order by mergedAt
        id: filter
        shell: bash
        run: |
          set -euo pipefail
          jq -c '
            { included:
              ( [ .[]
                  | select([.labels[].name] // [] | index("promote:uat"))
                ]
                | sort_by(.mergedAt)
              )
            }
          ' /tmp/merged.json > /tmp/included.json

          PRS="$(jq -r '[.included[].number] | join(",")' /tmp/included.json)"
          echo "prs_included=$PRS" >> "$GITHUB_OUTPUT"

          # Build pr->commits map
          jq -s 'map({(.number|tostring): .commits}) | add' /tmp/commitlists.json > /tmp/pr2commits.json

      - name: Create uat-candidate from current uat and cherry-pick included PRs
        if: ${{ steps.filter.outputs.prs_included != '' }}
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin uat develop --prune
          git checkout -B uat-candidate origin/uat

          jq -r '.included[].number' /tmp/included.json > /tmp/pr_order.txt

          while read -r PR; do
            [ -z "$PR" ] && continue
            echo "::group::Cherry-picking PR #$PR"
            COMMITS=$(jq -r --arg pr "$PR" '.[$pr] // [] | .[]' /tmp/pr2commits.json)
            if [ -z "$COMMITS" ]; then
              echo "No commits found for PR #$PR, skipping."
              echo "::endgroup::"; continue
            fi
            ok=true
            for c in $COMMITS; do
              if git cherry-pick -X theirs --keep-redundant-commits "$c"; then
                echo "Picked $c"
              else
                echo "Conflict on commit $c; aborting PR #$PR"
                ok=false
                git cherry-pick --abort || true
                break
              fi
            done
            $ok && echo "PR #$PR applied."
            echo "::endgroup::"
          done < /tmp/pr_order.txt

          git push -f origin uat-candidate

      - name: Create or update PR uat-candidate -> uat
        id: uat_pr
        shell: bash
        run: |
          set -euo pipefail
          TITLE="UAT promote: labeled PRs only"
          BODY=$'This PR promotes only PRs labeled `promote:uat` since the last UAT tag.\n\nIncluded PRs: '${{ steps.filter.outputs.prs_included }}

          PR_NUMBER="$(gh pr list --base uat --head uat-candidate --state open --json number --jq '.[0].number' || true)"
          if [[ -n "${PR_NUMBER}" && "${PR_NUMBER}" != "null" ]]; then
            gh pr edit "${PR_NUMBER}" --title "${TITLE}" --body "${BODY}"
          else
            URL="$(gh pr create --base uat --head uat-candidate --title "${TITLE}" --body "${BODY}")"
            PR_NUMBER="$(gh pr view "${URL}" --json number --jq .number)"
          fi
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"

      # OPTIONAL: turn on auto-merge (squash) so it merges after approvals/checks
      - name: Enable auto-merge (squash)
        if: ${{ steps.uat_pr.outputs.pr_number }}
        shell: bash
        run: gh pr merge ${{ steps.uat_pr.outputs.pr_number }} --squash --auto

      - name: Job summary
        shell: bash
        run: |
          {
            echo "### UAT Promotion Summary"
            echo "- Last UAT tag: \`${{ steps.last.outputs.last_tag || 'none' }}\`"
            echo "- Included PRs: \`${{ steps.filter.outputs.prs_included || 'none' }}\`"
            echo "- PR: #${{ steps.uat_pr.outputs.pr_number }}"
          } >> "$GITHUB_STEP_SUMMARY"
